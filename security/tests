// Security Fixes Test Script
// Tests the security vulnerabilities found in the audit
// Run with: node test-security-fixes.js

const axios = require('axios');
const crypto = require('crypto');

const SERVER_URL = process.env.TEST_SERVER_URL || 'https://license.spventerprises.com';
const WEBHOOK_SECRET = process.env.STRIPE_WEBHOOK_SECRET;
const ADMIN_API_KEY = process.env.ADMIN_API_KEY;

class SecurityFixTester {
  constructor() {
    this.results = [];
  }

  log(test, status, message, details = null) {
    const emoji = status === 'PASS' ? '‚úÖ' : status === 'FAIL' ? '‚ùå' : '‚ö†Ô∏è';
    console.log(`${emoji} ${test}: ${message}`);
    if (details) console.log(`   ${JSON.stringify(details)}`);
    this.results.push({ test, status, message, details });
  }

  // Test 1: Production Direct Activation (should be disabled)
  async testDirectActivation() {
    console.log('\nüîí Testing Direct Activation Security...');
    
    try {
      const response = await axios.post(`${SERVER_URL}/activate`, {
        email: `test-${Date.now()}@example.com`
      }, { validateStatus: () => true });

      if (response.status === 403) {
        this.log('Direct Activation', 'PASS', 'Properly disabled in production');
      } else if (response.status === 200) {
        this.log('Direct Activation', 'FAIL', 'Still enabled - security risk!');
      } else {
        this.log('Direct Activation', 'WARN', `Unexpected status: ${response.status}`);
      }
    } catch (error) {
      this.log('Direct Activation', 'FAIL', error.message);
    }
  }

  // Test 2: Admin Endpoint Authentication
  async testAdminAuth() {
    console.log('\nüîê Testing Admin Authentication...');
    
    // Test without auth
    try {
      const response = await axios.get(`${SERVER_URL}/admin/licenses`, {
        validateStatus: () => true
      });

      if (response.status === 401) {
        this.log('Admin Auth (No Key)', 'PASS', 'Properly protected');
      } else if (response.status === 200) {
        this.log('Admin Auth (No Key)', 'FAIL', 'Accessible without auth!');
      }
    } catch (error) {
      this.log('Admin Auth (No Key)', 'PASS', 'Properly blocked');
    }

    // Test with valid key (if provided)
    if (ADMIN_API_KEY) {
      try {
        const response = await axios.get(`${SERVER_URL}/admin/licenses`, {
          headers: { 'X-API-Key': ADMIN_API_KEY },
          validateStatus: () => true
        });

        if (response.status === 200) {
          this.log('Admin Auth (Valid Key)', 'PASS', 'Valid key accepted');
        } else {
          this.log('Admin Auth (Valid Key)', 'FAIL', 'Valid key rejected');
        }
      } catch (error) {
        this.log('Admin Auth (Valid Key)', 'FAIL', error.message);
      }
    }
  }

  // Test 3: Webhook Signature Validation
  async testWebhookSecurity() {
    console.log('\nüîó Testing Webhook Security...');
    
    if (!WEBHOOK_SECRET) {
      this.log('Webhook Security', 'SKIP', 'No webhook secret provided');
      return;
    }

    // Test without signature
    try {
      const response = await axios.post(`${SERVER_URL}/webhook`, {
        id: 'evt_test',
        type: 'checkout.session.completed'
      }, { validateStatus: () => true });

      if (response.status === 400) {
        this.log('Webhook No Signature', 'PASS', 'Properly rejected');
      } else {
        this.log('Webhook No Signature', 'FAIL', 'Accepted without signature!');
      }
    } catch (error) {
      this.log('Webhook No Signature', 'PASS', 'Properly blocked');
    }

    // Test with valid signature
    const payload = JSON.stringify({
      id: `evt_test_${Date.now()}`,
      type: 'checkout.session.completed',
      data: { object: { customer_email: 'test@example.com', payment_status: 'paid' } }
    });
    
    const timestamp = Math.floor(Date.now() / 1000);
    const signature = crypto.createHmac('sha256', WEBHOOK_SECRET)
      .update(`${timestamp}.${payload}`)
      .digest('hex');

    try {
      const response = await axios.post(`${SERVER_URL}/webhook`, payload, {
        headers: {
          'Content-Type': 'application/json',
          'stripe-signature': `t=${timestamp},v1=${signature}`
        },
        validateStatus: () => true
      });

      if (response.status === 200) {
        this.log('Webhook Valid Signature', 'PASS', 'Valid signature accepted');
      } else {
        this.log('Webhook Valid Signature', 'FAIL', 'Valid signature rejected');
      }
    } catch (error) {
      this.log('Webhook Valid Signature', 'FAIL', error.message);
    }
  }

  // Test 4: Rate Limiting
  async testRateLimiting() {
    console.log('\n‚ö° Testing Rate Limiting...');
    
    try {
      // Send 15 rapid requests
      const requests = Array.from({ length: 15 }, (_, i) => 
        axios.post(`${SERVER_URL}/validate`, { key: `test-${i}` }, {
          validateStatus: () => true
        }).catch(err => err.response || err)
      );

      const responses = await Promise.all(requests);
      const rateLimited = responses.some(r => r.status === 429);

      if (rateLimited) {
        this.log('Rate Limiting', 'PASS', 'Rate limiting is active');
      } else {
        this.log('Rate Limiting', 'FAIL', 'No rate limiting detected');
      }
    } catch (error) {
      this.log('Rate Limiting', 'FAIL', error.message);
    }
  }

  // Test 5: Input Validation
  async testInputValidation() {
    console.log('\nüõ°Ô∏è Testing Input Validation...');
    
    const maliciousInputs = [
      "'; DROP TABLE licenses; --",
      '<script>alert("xss")</script>',
      'test@test.com; rm -rf /',
      'a'.repeat(1000) + '@test.com'
    ];

    let protectedCount = 0;
    for (const input of maliciousInputs) {
      try {
        const response = await axios.post(`${SERVER_URL}/activate`, {
          email: input
        }, { validateStatus: () => true });

        if (response.status >= 400) {
          protectedCount++;
        }
      } catch (error) {
        protectedCount++;
      }
    }

    if (protectedCount === maliciousInputs.length) {
      this.log('Input Validation', 'PASS', 'All malicious inputs blocked');
    } else {
      this.log('Input Validation', 'FAIL', 
        `${maliciousInputs.length - protectedCount} malicious inputs accepted`);
    }
  }

  async runAllTests() {
    console.log('üîí Running Security Fix Tests\n');
    console.log(`Server: ${SERVER_URL}`);
    console.log(`Webhook Secret: ${WEBHOOK_SECRET ? 'PROVIDED' : 'NOT SET'}`);
    console.log(`Admin Key: ${ADMIN_API_KEY ? 'PROVIDED' : 'NOT SET'}\n`);

    await this.testDirectActivation();
    await this.testAdminAuth();
    await this.testWebhookSecurity();
    await this.testRateLimiting();
    await this.testInputValidation();

    // Summary
    const passed = this.results.filter(r => r.status === 'PASS').length;
    const failed = this.results.filter(r => r.status === 'FAIL').length;
    const warned = this.results.filter(r => r.status === 'WARN').length;
    const skipped = this.results.filter(r => r.status === 'SKIP').length;

    console.log('\n' + '='.repeat(50));
    console.log('üìä SECURITY TEST RESULTS');
    console.log('='.repeat(50));
    console.log(`‚úÖ Passed: ${passed}`);
    console.log(`‚ùå Failed: ${failed}`);
    console.log(`‚ö†Ô∏è  Warnings: ${warned}`);
    console.log(`‚è≠Ô∏è  Skipped: ${skipped}`);

    if (failed === 0) {
      console.log('\nüéâ All security tests passed!');
      console.log('Your system is properly secured.');
    } else {
      console.log('\n‚ö†Ô∏è  Some security tests failed.');
      console.log('Please review and fix the issues above.');
    }
  }
}

// Run if called directly
if (require.main === module) {
  const tester = new SecurityFixTester();
  tester.runAllTests().catch(console.error);
}

module.exports = SecurityFixTester; 